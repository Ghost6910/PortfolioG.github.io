<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Portfolio</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
    <meta charset="UTF-8" />
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <!-- Loading Screen -->
    <div id="loading-screen">
      <div class="loader"></div>
      <p>Loading models</p>
    </div>

    <style>
      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: rgb(255, 145, 0);
        font-family: monospace;
        font-size: 18px;
        z-index: 9999;
        transition: opacity 5s ease;
      }

      #loading-screen.fade-out {
        opacity: 0;
        pointer-events: none;
      }

      .loader {
        border: 5px solid #333;
        border-top: 5px solid rgb(255, 145, 0);
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>

    <script>
      let modelsToLoad = 12; // จำนวนโมเดลทั้งหมดที่ต้องโหลด
      let modelsLoaded = 0;

      function checkLoadingDone() {
        modelsLoaded++;
        if (modelsLoaded >= modelsToLoad) {
          const screen = document.getElementById("loading-screen");
          screen.classList.add("fade-out");
          setTimeout(() => screen.remove(), 500);
        }
      }

      // === Gradient map สำหรับ Toon (โทน 4 ขั้น) ===
      function makeGradientMap(steps = 4) {
        const size = 256;
        const data = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
          const t = Math.floor((i / size) * steps) / (steps - 1);
          data[i] = Math.round(t * 255);
        }
        const tex = new THREE.DataTexture(data, size, 1, THREE.LuminanceFormat);
        tex.needsUpdate = true;
        tex.minFilter = THREE.NearestFilter;
        tex.magFilter = THREE.NearestFilter;
        return tex;
      }
      const CEL_GRADIENT = makeGradientMap(4);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.setPixelRatio(window.devicePixelRatio); // ทำให้ภาพคมขึ้น
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ทำให้เงาและแสงนุ่ม
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(1.66, 1.6, 0.89);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0.79, 1.5, 0.31); // พิกัดที่อยากให้มอง
      camera.rotation.set(-25.8, 88.1, 25.8); // มุมกล้อง
      const rx = THREE.MathUtils.degToRad(8.2);
      const ry = THREE.MathUtils.degToRad(62.5);
      const rz = THREE.MathUtils.degToRad(-7.3);
      camera.rotation.set(rx, ry, rz);
      const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
      controls.target.copy(camera.position).add(dir);
      controls.update();

      // ==== Camera jump/lerp targets ====
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const backRoots = [];

      let __audioCtx;
      function __unlockAudio() {
        try {
          __audioCtx =
            __audioCtx ||
            new (window.AudioContext || window.webkitAudioContext)();
          if (__audioCtx.state === "suspended") __audioCtx.resume();
        } catch (e) {
          /* ignore */
        }
      }
      window.addEventListener("pointerdown", __unlockAudio, { once: true });
      window.addEventListener("touchstart", __unlockAudio, { once: true });

      const backClickSfx = new Audio(
        "https://Ghost6910.github.io/PortfolioG.github.io/sound/chainsaw.mp3"
      );
      backClickSfx.preload = "auto";
      backClickSfx.volume = 0.2;

      function playBackClick() {
        const a = backClickSfx.cloneNode();
        a.volume = backClickSfx.volume;
        a.play();
      }

      // เป้าหมายตำแหน่งกล้องและจุดมอง (แก้ตัวเลขตามที่ต้องการ)
      const camTargetPos = new THREE.Vector3(2.0, 1.6, 3.0);
      const camTargetLook = new THREE.Vector3(2.0, 1.5, -0.02);
      let camLerping = false;

      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      window.addEventListener("click", async (e) => {
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(backRoots, true);
        if (!hits.length) return;

        // หา root ที่แท้จริง
        const hitObj = hits[0].object;
        let node = hitObj,
          root = null;
        while (node) {
          if (backRoots.includes(node)) {
            root = node;
            break;
          }
          node = node.parent;
        }
        if (!root) return;

        playBackClick();

        if (root === backright) {
          camTargetPos.set(1.5, 1.6, 0.8);
          camTargetLook.set(0.78, 1.5, 0.39);
        } else if (root === backright1) {
          camTargetPos.set(1.55, 1.6, 0.83);
          camTargetLook.set(0.78, 1.6, 0.39);
        } else if (root === backleft) {
          camTargetPos.set(1.55, 1.6, 0.83);
          camTargetLook.set(0.78, 1.6, 0.39);
        } else if (root === aboutme1) {
          camTargetPos.set(0.24, 1.6, 3.76);
          camTargetLook.set(-1.79, 1.6, 5.07);
        } else if (root === pbrm1) {
          camTargetPos.set(-1.84, 1.6, -2.94);
          camTargetLook.set(-1.96, 1.59, -4.3);
        } else if (root === musicd) {
          // ---- เล่นเพลงแบบปลอดภัย ----
          let s = musicd.userData.clickSound;
          if (!s) {
            s = new Audio(musicd.userData.clickSoundSrc);
            s.crossOrigin = "anonymous";
            s.preload = "auto";
            s.volume = 0.2;
            musicd.userData.clickSound = s;
          }

          // ปลดล็อกเสียง (ถ้ายัง)
          __unlockAudio();

          try {
            s.currentTime = 0;
            await s.play();
          } catch (err) {
            try {
              if (__audioCtx && __audioCtx.state === "suspended") {
                await __audioCtx.resume();
              }
              await s.play();
            } catch (e2) {
              console.warn("Play failed:", e2);
            }
          }

          camTargetPos.set(1.32, 1.6, -16.61);
          camTargetLook.set(1.32, 1.6, -24.6);

          // ถ้าไม่อยากให้เปลี่ยนเป็นสีเขียวเวลา "คลิก" ด้วย ให้คอมเมนต์บล็อคนี้ทิ้งได้
          musicd.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.material.color.set(0x00ff00);
            }
          });
        }

        // กด backleft แล้วหยุดเพลง
        if (root === backleft) {
          if (musicd && musicd.userData.clickSound) {
            musicd.userData.clickSound.pause();
            musicd.userData.clickSound.currentTime = 0;
          }
        }

        camLerping = true;
      });

      // อัปเดตเมาส์สำหรับ raycaster
      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      // === Back (shared) Vertex/Fragment Shaders ===
      const backVert = `
uniform float uTime;
varying vec2 vUv;
void main() {
  vUv = uv;
  vec3 p = position;
  p.y += sin(p.x * 4.0 + uTime * 2.5) * 0.1;
  p.y += cos(p.z * 3.0 + uTime * 2.0) * 0.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
}
`;
      const backFrag = `
uniform vec3 uColor;
varying vec2 vUv;
void main() {
  float g = smoothstep(0.0, 1.0, vUv.y);
  vec3 col = mix(uColor * 0.7, uColor, g);
  gl_FragColor = vec4(col, 1.0);
}
`;
      const backMat = new THREE.ShaderMaterial({
        vertexShader: backVert,
        fragmentShader: backFrag,
        uniforms: {
          uTime: { value: 0.0 },
          uColor: { value: new THREE.Color(0x969696) },
        },
        side: THREE.DoubleSide,
      });

      const backMatHover = new THREE.ShaderMaterial({
        vertexShader: backVert,
        fragmentShader: backFrag,
        uniforms: {
          uTime: { value: 0.0 },
          uColor: { value: new THREE.Color(0xff8c00) },
        },
        side: THREE.DoubleSide,
      });

      // ===================== Lights =====================
      scene.add(new THREE.AxesHelper(2));

      const ambient = new THREE.AmbientLight(0xffffff, 1.01);
      scene.add(ambient);

      const hemi = new THREE.HemisphereLight(0xdd0000, 0xe92828, 1.33);
      hemi.position.set(0, 124, 0);
      scene.add(hemi);

      // Directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
      dirLight.position.set(65.2, 51.8, 27);
      dirLight.castShadow = true;

      // Target ของไฟ
      const lightTarget1 = new THREE.Object3D();
      lightTarget1.position.set(6.9, -1.1, 4.7);
      scene.add(lightTarget1);
      dirLight.target = lightTarget1;

      // Shadow settings
      dirLight.shadow.bias = 0.0002;
      dirLight.shadow.normalBias = 0.5;

      dirLight.shadow.mapSize.set(4096, 4096); // เพิ่มความละเอียดเงา
      dirLight.shadow.bias = -0.0002;
      dirLight.shadow.normalBias = 0.3;

      dirLight.penumbra = 0.5;
      dirLight.intensity = 1.1;

      // ปรับระยะกล้องเงา (ขนาดพื้นที่ที่คำนวณเงา)
      const SHADOW_SIZE = 60;
      Object.assign(dirLight.shadow.camera, {
        left: -SHADOW_SIZE,
        right: SHADOW_SIZE,
        top: SHADOW_SIZE,
        bottom: -SHADOW_SIZE,
        near: 0.5,
        far: 200,
      });

      scene.add(dirLight);

      // เป้าหมายของไฟ (เล็งไปที่ origin)
      const lightTarget = new THREE.Object3D();
      lightTarget.position.set(0, 0, 0);
      scene.add(lightTarget);
      dirLight.target = lightTarget;

      // Helpers (เปิด/ปิดได้จาก GUI)
      const dirHelper = new THREE.DirectionalLightHelper(dirLight, 5);
      dirHelper.visible = false;
      scene.add(dirHelper);

      const camHelper = new THREE.CameraHelper(dirLight.shadow.camera);
      camHelper.visible = false;
      scene.add(camHelper);

      // === HUD พิกัด ===
      const hud = document.createElement("div");
      Object.assign(hud.style, {
        position: "fixed",
        bottom: "12px",
        left: "12px",
        padding: "8px 10px",
        background: "rgba(0,0,0,0.55)",
        color: "#0f0",
        font: "12px/1.4 monospace",
        borderRadius: "6px",
        whiteSpace: "pre",
        pointerEvents: "none",
        zIndex: 9999,
      });
      document.body.appendChild(hud);

      //-------------------Gui-----------------------------

      const gui = new dat.GUI({ width: 360 });
      gui.domElement.style.maxHeight = "520px";
      gui.domElement.style.overflowY = "auto";
      gui.close();

      // Ambient/Hemi
      const ambFolder = gui.addFolder("Ambient & Hemisphere");
      ambFolder.add(ambient, "intensity", 0, 2, 0.01).name("Ambient Intensity");
      ambFolder.add(hemi, "intensity", 0, 2, 0.01).name("Hemi Intensity");
      ambFolder.add(hemi.position, "y", 0, 200, 1).name("Hemi Height");
      ambFolder
        .addColor({ sky: "#ffffff" }, "sky")
        .name("Hemi Sky Color")
        .onChange((v) => hemi.color.set(v));
      ambFolder
        .addColor({ ground: "#404040" }, "ground")
        .name("Hemi Ground Color")
        .onChange((v) => hemi.groundColor.set(v));
      ambFolder.open();

      // Directional
      const lightFolder = gui.addFolder("Directional Light");
      lightFolder.add(dirLight, "intensity", 0, 2, 0.01).name("Intensity");
      lightFolder
        .add(dirLight.position, "x", -100, 100, 0.1)
        .name("Pos X")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(dirLight.position, "y", 0, 100, 0.1)
        .name("Pos Y")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(dirLight.position, "z", -100, 100, 0.1)
        .name("Pos Z")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(lightTarget.position, "x", -50, 50, 0.1)
        .name("Target X")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .add(lightTarget.position, "y", -50, 50, 0.1)
        .name("Target Y")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .add(lightTarget.position, "z", -50, 50, 0.1)
        .name("Target Z")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .addColor({ color: "#ffffff" }, "color")
        .name("Color")
        .onChange((v) => {
          dirLight.color.set(v);
          dirHelper.update();
        });
      lightFolder.add(dirHelper, "visible").name("Show Dir Helper");
      lightFolder.add(camHelper, "visible").name("Show Shadow Cam");

      // Shadows tuning
      const shadowFolder = lightFolder.addFolder("Shadow");
      shadowFolder
        .add(dirLight.shadow, "bias", -0.01, 0.01, 0.0001)
        .name("Bias");
      shadowFolder
        .add(dirLight.shadow, "normalBias", 0, 2, 0.01)
        .name("Normal Bias");
      shadowFolder
        .add(dirLight.shadow.camera, "near", 0.1, 50, 0.1)
        .name("Cam Near")
        .onChange(() => {
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      shadowFolder
        .add(dirLight.shadow.camera, "far", 10, 500, 1)
        .name("Cam Far")
        .onChange(() => {
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      shadowFolder
        .add({ size: SHADOW_SIZE }, "size", 10, 200, 1)
        .name("Frustum Size")
        .onChange((v) => {
          dirLight.shadow.camera.left = -v;
          dirLight.shadow.camera.right = v;
          dirLight.shadow.camera.top = v;
          dirLight.shadow.camera.bottom = -v;
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      lightFolder.open();

      //-------------------Ground-----------------------------

      // Add ground plane with texture
      const groundTexture = new THREE.TextureLoader().load(
        "https://ghost6910.github.io/GhostModel.github.io/Poliigon_GrassPatchyGround_4585_BaseColor.jpg"
      );
      groundTexture.wrapS = THREE.RepeatWrapping;
      groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(8, 8);

      // Create ground plane
      const groundGeo = new THREE.PlaneGeometry(7.5, 13.5);
      const groundMat = new THREE.MeshStandardMaterial({
        map: groundTexture,
        roughness: 0.8,
        metalness: 0.2,
      });

      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
      checkLoadingDone();

      // Set scene background
      scene.background = new THREE.Color(0xbfd1e5);
      const bgTexture = new THREE.TextureLoader().load("");
      scene.background = bgTexture;

      //-------------------Model-----------------------------

      let Ghost = null;
      // GLTF/GLB
      const draco = new THREE.DRACOLoader();
      draco.setDecoderPath(
        "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/"
      );

      const loader = new THREE.GLTFLoader();
      loader.setDRACOLoader(draco);

      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/Ramen.glb",
        (gltf) => {
          const shopmodel = gltf.scene;
          shopmodel.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          shopmodel.position.set(1.5, 0.2, 0);
          scene.add(shopmodel);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //CHdeath
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/CHdeath.glb",
        (gltf) => {
          const CHdeath = gltf.scene;
          CHdeath.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          CHdeath.position.set(0, 1, -22.92);
          CHdeath.scale.set(0.004, 0.004, 0.004);
          CHdeath.rotation.y = Math.PI / 2;
          scene.add(CHdeath);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //hddr1
      let hddr1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/hddr1.glb",
        (gltf) => {
          hddr1 = gltf.scene;
          hddr1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          hddr1.position.set(1, 1, 1);
          hddr1.scale.set(100, 100, 100);
          scene.add(hddr1);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // Makima
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/makima.glb",
        (gltf) => {
          const makima = gltf.scene;
          makima.traverse((o) => {
            if (o.isMesh) {
              const tex = o.material && o.material.map ? o.material.map : null;
              const baseCol =
                o.material && o.material.color
                  ? o.material.color.clone()
                  : new THREE.Color(0xffffff);

              // ปรับการกรอง texture ให้เนียนขึ้น
              if (tex) {
                tex.encoding = THREE.sRGBEncoding;
                tex.needsUpdate = true;
                tex.minFilter = THREE.LinearMipmapLinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
              }

              // ใช้ toon ที่ "ขั้น" เยอะขึ้น + เปิด dithering
              const toonMat = new THREE.MeshToonMaterial({
                color: baseCol,
                map: tex,
                gradientMap: makeGradientMap(16), // จากเดิม 4 --> 16 ขั้น เนียนขึ้น
                dithering: true, // ช่วยแตกเม็ด banding ให้กลมกลืน
              });

              toonMat.color.multiplyScalar(0.7);

              o.material = toonMat;
              o.castShadow = true;
              o.receiveShadow = true;
            }
          });

          // === เพิ่มเส้นขอบรอบนอก ===
          const outline = makima.clone();
          outline.traverse((o) => {
            if (o.isMesh) {
              // วัสดุสีดำ ขอบด้านหลัง
              o.material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide,
              });
              // ขยายออกเล็กน้อย (หนาเส้นขอบ)
              o.scale.multiplyScalar(1.002);
            }
          });
          makima.add(outline);

          makima.position.set(0.6, 0.2, -0.05);
          makima.scale.set(1, 1, 1);
          //makima.rotation.y = Math.PI / 2;
          makima.rotation.y = THREE.MathUtils.degToRad(45);
          scene.add(makima);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // G.host
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/G.host.glb",
        (gltf) => {
          Ghost = gltf.scene;
          Ghost.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          Ghost.position.set(-1.3, 0.8, 6);
          Ghost.scale.set(1, 1, 1);
          //makima.rotation.y = Math.PI / 2;
          Ghost.rotation.y = THREE.MathUtils.degToRad(130);
          scene.add(Ghost);
          checkLoadingDone();
          Ghost.userData.baseY = Ghost.position.y;
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // ku logo
      loader.load(
        "ku.glb",
        (gltf) => {
          const ku = gltf.scene;
          ku.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          ku.position.set(-2.2, 2.1, 4.5);
          ku.scale.set(0.5, 0.5, 0.5);
          //ku.rotation.y = Math.PI / 2;
          ku.rotation.y = THREE.MathUtils.degToRad(110);
          scene.add(ku);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //rusty
      let rusty;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/rusty.glb",
        (gltf) => {
          rusty = gltf.scene;
          // ปรับวัสดุของ rusty ให้เห็นชัด
          rusty.traverse((o) => {
            if (o.isMesh && o.material) {
              // เพิ่มค่า metalness/roughness ให้เหมาะกับไฟ
              o.material.metalness = 0.5;
              o.material.roughness = 0.3;
              o.material.envMapIntensity = 1.2;
              o.material.needsUpdate = true;
            }
          });

          rusty.position.set(-2.3, 1.4, -4.3);
          rusty.scale.set(0.5, 0.5, 0.5);

          // เพิ่มไฟเฉพาะที่ส่อง rusty
          const ballLight = new THREE.SpotLight(0xffffff, 1.2);
          ballLight.position.set(-2, 2, -3);
          ballLight.angle = Math.PI / 6;
          ballLight.penumbra = 0.3;
          ballLight.castShadow = true;
          ballLight.target = rusty;
          scene.add(ballLight);
          scene.add(ballLight.target);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //vinyl_record
      let vinyl_record;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/vinyl_record.glb",
        (gltf) => {
          vinyl_record = gltf.scene;
          // ปรับวัสดุของ vinyl_record ให้เห็นชัด
          vinyl_record.traverse((o) => {
            if (o.isMesh && o.material) {
              // เพิ่มค่า metalness/roughness ให้เหมาะกับไฟ
              o.material.metalness = 0.2;
              o.material.roughness = 0;
              o.material.envMapIntensity = 1.2;
              o.material.needsUpdate = true;
            }
          });

          vinyl_record.position.set(1.4, 1.6, -25.3);
          vinyl_record.scale.set(4, 4, 4);

          // เพิ่มไฟเฉพาะที่ส่อง vinyl_record
          const ballLight1 = new THREE.SpotLight(0xffffff, 1.2);
          ballLight1.position.set(-2, 2, -3);
          ballLight1.angle = Math.PI / 6;
          ballLight1.penumbra = 0.3;
          ballLight1.castShadow = false;
          ballLight1.target = vinyl_record;
          scene.add(ballLight1);
          scene.add(ballLight1.target);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // clip_b
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/Clip.glb",
        (gltf) => {
          const Clip = gltf.scene;
          Clip.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });

          Clip.position.set(0.7, 1.5, 0.1);
          Clip.scale.set(0.17, 0.17, 0.17);
          Clip.rotation.y = Math.PI / 2;
          Clip.rotation.z = Math.PI / 2;
          const tabledjLight = new THREE.SpotLight(0xffffff, 1.2);
          tabledjLight.position.set(1.5, 2.5, 1); // ปรับตำแหน่งไฟ
          tabledjLight.angle = Math.PI / 6;
          tabledjLight.penumbra = 0.3;
          tabledjLight.castShadow = true;
          tabledjLight.target = Clip;
          scene.add(tabledjLight);
          scene.add(tabledjLight.target);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //aboutme1
      let aboutme1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/aboutme1.glb",
        (gltf) => {
          aboutme1 = gltf.scene;
          aboutme1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }

                o.material.color.set(0x969696);
                //0xffffff = ขาว, 0x000000 = ดำ, 0x00ff00 = เขียว

                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          aboutme1.position.set(0.8, 1.4, 0.55);
          aboutme1.scale.set(0.11, 0.11, 0.11);
          aboutme1.rotation.y = Math.PI / 2;
          scene.add(aboutme1);
          backRoots.push(aboutme1);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //pbrm1
      let pbrm1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/pbrm1.glb",
        (gltf) => {
          pbrm1 = gltf.scene;
          pbrm1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                // ถ้ามี texture map ให้ตั้ง encoding
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }

                o.material.color.set(0x969696);
                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          pbrm1.position.set(0.8, 1.53, 0.63);
          pbrm1.scale.set(0.1, 0.1, 0.1);
          pbrm1.rotation.y = Math.PI / 2;
          scene.add(pbrm1);
          backRoots.push(pbrm1);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //My name
      let namenew;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/namenew.glb",
        (gltf) => {
          namenew = gltf.scene;
          namenew.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                // ถ้ามี texture map ให้ตั้ง encoding
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }
                o.material.color.set(0x282828);
                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          namenew.position.set(-2.2, 1.2, 4.5);
          namenew.scale.set(0.2, 0.2, 0.2);
          //namenew.rotation.y = Math.PI / 2;
          namenew.rotation.y = THREE.MathUtils.degToRad(110);
          scene.add(namenew);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back right
      let backright;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backright.glb",
        (gltf) => {
          backright = gltf.scene;
          backright.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backright.position.set(-2.2, 1.05, 4.5);
          backright.scale.set(0.15, 0.15, 0.15);
          //backright.rotation.y = Math.PI / 2;
          backright.rotation.y = THREE.MathUtils.degToRad(110);
          scene.add(backright);
          backRoots.push(backright);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back right
      let backright1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backright.glb",
        (gltf) => {
          backright1 = gltf.scene;
          backright1.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backright1.position.set(-1.4, 1.4, -4.3);
          backright1.scale.set(0.15, 0.15, 0.15);
          //backright1.rotation.y = Math.PI / 2;
          scene.add(backright1);
          backRoots.push(backright1);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back left
      let backleft;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backleft.glb",
        (gltf) => {
          backleft = gltf.scene;
          backleft.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backleft.position.set(-0.3, 1.15, -18.47);
          backleft.scale.set(0.15, 0.15, 0.15);
          //backleft.rotation.y = Math.PI / 2;
          scene.add(backleft);
          backRoots.push(backleft);
          checkLoadingDone();
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // musicd
      let musicd;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/vinyl_single.glb",
        (gltf) => {
          musicd = gltf.scene;
          musicd.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          musicd.position.set(0.75, 1.5, 0.92);
          musicd.scale.set(0.14, 0.14, 0.14);
          musicd.rotateX(-Math.PI / 2);
          musicd.rotation.z = THREE.MathUtils.degToRad(270);
          scene.add(musicd);
          backRoots.push(musicd);
          checkLoadingDone();

          musicd.userData.clickSound = null; // จะสร้างตอนคลิก
          musicd.userData.clickSoundSrc =
            "https://Ghost6910.github.io/PortfolioG.github.io/sound/CHAINSAW_MAN_Opening_KICK_BACK.mp3";

          musicd.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // Loop
      (function animate() {
        requestAnimationFrame(animate);
        const dt = (
          window.__clock || (window.__clock = new THREE.Clock())
        ).getDelta();

        if (rusty) {
          rusty.rotation.y += 0.005;
        }
        if (vinyl_record) {
          vinyl_record.rotation.z += 0.01;
        }
        if (musicd) {
          musicd.rotation.x += 0.01;
        }

        backMat.uniforms.uTime.value = performance.now() * 0.001;
        // เวลาให้ shader ทั้งคู่
        const t = performance.now() * 0.001;
        backMat.uniforms.uTime.value = t;
        backMatHover.uniforms.uTime.value = t;

        // ตรวจจับชี้และสลับสีเขียวให้เฉพาะตัวที่ถูกชี้
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(backRoots, true);
        let hoveredRoot = null;
        if (hits.length) {
          const hit = hits[0].object;
          hoveredRoot = backRoots.find(
            (root) =>
              hit === root || root.children.includes(hit) || root === hit.parent
          );
        }
        for (const root of backRoots) {
          if (root === musicd) {
            continue;
          }
          root.traverse((o) => {
            if (o.isMesh) {
              o.material = root === hoveredRoot ? backMatHover : backMat;
            }
          });
        }

        // ==== Lerp กล้องเมื่อมีคำสั่งย้ายมุม ====
        if (camLerping) {
          camera.position.lerp(camTargetPos, 0.08);
          controls.target.lerp(camTargetLook, 0.08);
          controls.update();

          // หยุดเมื่อใกล้พอ
          if (
            camera.position.distanceTo(camTargetPos) < 0.02 &&
            controls.target.distanceTo(camTargetLook) < 0.02
          ) {
            camera.position.copy(camTargetPos);
            controls.target.copy(camTargetLook);
            camLerping = false;
          }
        }

        if (Ghost) {
          const t = performance.now() * 0.001; // เวลา (วินาที)
          Ghost.position.y = Ghost.userData.baseY + Math.sin(t * 0.9) * 0.2;
        }

        renderer.render(scene, camera);
      })();

      // Resize
      window.addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>

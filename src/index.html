<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Portfolio</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
    <meta charset="UTF-8" />
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
      // === Gradient map สำหรับ Toon (โทน 4 ขั้น) ===
      function makeGradientMap(steps = 4) {
        const size = 256;
        const data = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
          const t = Math.floor((i / size) * steps) / (steps - 1);
          data[i] = Math.round(t * 255);
        }
        const tex = new THREE.DataTexture(data, size, 1, THREE.LuminanceFormat);
        tex.needsUpdate = true;
        tex.minFilter = THREE.NearestFilter;
        tex.magFilter = THREE.NearestFilter;
        return tex;
      }
      const CEL_GRADIENT = makeGradientMap(4);

      // Renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.outputEncoding = THREE.sRGBEncoding; // ให้สี/texture ตรง
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(1.66, 1.6, 0.89);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0.79, 1.5, 0.31); // พิกัดที่อยากให้มอง
      camera.rotation.set(-25.8, 88.1, 25.8); // มุมกล้อง
      const rx = THREE.MathUtils.degToRad(8.2);
      const ry = THREE.MathUtils.degToRad(62.5);
      const rz = THREE.MathUtils.degToRad(-7.3);
      camera.rotation.set(rx, ry, rz);
      const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
      controls.target.copy(camera.position).add(dir);
      controls.update();

      // ==== Camera jump/lerp targets ====
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const backRoots = [];

      const backClickSfx = new Audio(
        "https://Ghost6910.github.io/PortfolioG.github.io/sound/chainsaw.mp3"
      );
      backClickSfx.preload = "auto";
      backClickSfx.volume = 0.2;

      function playBackClick() {
        const a = backClickSfx.cloneNode();
        a.volume = backClickSfx.volume;
        a.play();
      }

      // เป้าหมายตำแหน่งกล้องและจุดมอง (แก้ตัวเลขตามที่ต้องการ)
      const camTargetPos = new THREE.Vector3(2.0, 1.6, 3.0);
      const camTargetLook = new THREE.Vector3(2.0, 1.5, -0.02);
      let camLerping = false;

      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      window.addEventListener("click", (e) => {
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(backRoots, true);
        if (!hits.length) return;

        // หา root ที่แท้จริง (walk ขึ้นไปจนเจอ object ที่อยู่ใน backRoots)
        const hitObj = hits[0].object;
        let node = hitObj,
          root = null;
        while (node) {
          if (backRoots.includes(node)) {
            root = node;
            break;
          }
          node = node.parent;
        }
        if (!root) return;

        playBackClick();

        if (root === backright) {
          camTargetPos.set(1.5, 1.6, 0.8);
          camTargetLook.set(0.78, 1.5, 0.39);
        } else if (root === backright1) {
          camTargetPos.set(1.55, 1.6, 0.83);
          camTargetLook.set(0.78, 1.6, 0.39);
        } else if (root === backleft) {
          camTargetPos.set(1.55, 1.6, 0.83);
          camTargetLook.set(0.78, 1.6, 0.39);
        } else if (root === aboutme1) {
          camTargetPos.set(0.24, 1.6, 3.76);
          camTargetLook.set(-1.79, 1.6, 5.07);
        } else if (root === Pbrtext) {
          camTargetPos.set(-1.84, 1.6, -2.94);
          camTargetLook.set(-1.96, 1.59, -4.3);
        } else if (root === musicd) {
          const s = musicd.userData.clickSound;
          if (s) {
            s.currentTime = 0; // รีเซ็ตให้เล่นใหม่ทุกครั้ง
            s.play();
          }
          camTargetPos.set(1.32, 1.6, -16.61);
          camTargetLook.set(1.32, 1.6, -24.6);

          musicd.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.material.color.set(0x00ff00);
            }
          });
        }

        camLerping = true; // เริ่มเลื่อนกล้อง
      });

      // อัปเดตเมาส์สำหรับ raycaster
      window.addEventListener("mousemove", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      // === Back (shared) Vertex/Fragment Shaders ===
      const backVert = `
uniform float uTime;
varying vec2 vUv;
void main() {
  vUv = uv;
  vec3 p = position;
  p.y += sin(p.x * 4.0 + uTime * 2.5) * 0.1;
  p.y += cos(p.z * 3.0 + uTime * 2.0) * 0.1;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
}
`;
      const backFrag = `
uniform vec3 uColor;
varying vec2 vUv;
void main() {
  float g = smoothstep(0.0, 1.0, vUv.y);
  vec3 col = mix(uColor * 0.7, uColor, g);
  gl_FragColor = vec4(col, 1.0);
}
`;
      const backMat = new THREE.ShaderMaterial({
        vertexShader: backVert,
        fragmentShader: backFrag,
        uniforms: {
          uTime: { value: 0.0 },
          uColor: { value: new THREE.Color(0x969696) },
        },
        side: THREE.DoubleSide,
      });

      const backMatHover = new THREE.ShaderMaterial({
        vertexShader: backVert,
        fragmentShader: backFrag,
        uniforms: {
          uTime: { value: 0.0 },
          uColor: { value: new THREE.Color(0x00ff00) },
        },
        side: THREE.DoubleSide,
      });

      // ===================== Lights =====================
      scene.add(new THREE.AxesHelper(2));

      const ambient = new THREE.AmbientLight(0xffffff, 1.01);
      scene.add(ambient);

      const hemi = new THREE.HemisphereLight(0xdd0000, 0xe92828, 1.33);
      hemi.position.set(0, 124, 0);
      scene.add(hemi);

      // Directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
      dirLight.position.set(65.2, 51.8, 27);
      dirLight.castShadow = true;

      // Target ของไฟ
      const lightTarget1 = new THREE.Object3D();
      lightTarget1.position.set(6.9, -1.1, 4.7);
      scene.add(lightTarget1);
      dirLight.target = lightTarget1;

      // Shadow settings
      dirLight.shadow.bias = 0.0002; 
      dirLight.shadow.normalBias = 0.5; 

      dirLight.shadow.mapSize.set(2048, 2048);
      dirLight.shadow.bias = -0.0005;
      dirLight.shadow.normalBias = 0.5;

      // ปรับระยะกล้องเงา (ขนาดพื้นที่ที่คำนวณเงา)
      const SHADOW_SIZE = 60;
      Object.assign(dirLight.shadow.camera, {
        left: -SHADOW_SIZE,
        right: SHADOW_SIZE,
        top: SHADOW_SIZE,
        bottom: -SHADOW_SIZE,
        near: 0.5,
        far: 200,
      });

      scene.add(dirLight);

      // เป้าหมายของไฟ (เล็งไปที่ origin)
      const lightTarget = new THREE.Object3D();
      lightTarget.position.set(0, 0, 0);
      scene.add(lightTarget);
      dirLight.target = lightTarget;

      // Helpers (เปิด/ปิดได้จาก GUI)
      const dirHelper = new THREE.DirectionalLightHelper(dirLight, 5);
      dirHelper.visible = false;
      scene.add(dirHelper);

      const camHelper = new THREE.CameraHelper(dirLight.shadow.camera);
      camHelper.visible = false;
      scene.add(camHelper);

      // === HUD พิกัด ===
      const hud = document.createElement("div");
      Object.assign(hud.style, {
        position: "fixed",
        bottom: "12px",
        left: "12px",
        padding: "8px 10px",
        background: "rgba(0,0,0,0.55)",
        color: "#0f0",
        font: "12px/1.4 monospace",
        borderRadius: "6px",
        whiteSpace: "pre",
        pointerEvents: "none",
        zIndex: 9999,
      });
      document.body.appendChild(hud);

      //-------------------Gui-----------------------------

      const gui = new dat.GUI({ width: 360 });
      gui.domElement.style.maxHeight = "520px";
      gui.domElement.style.overflowY = "auto";
      gui.close();

      // Ambient/Hemi
      const ambFolder = gui.addFolder("Ambient & Hemisphere");
      ambFolder.add(ambient, "intensity", 0, 2, 0.01).name("Ambient Intensity");
      ambFolder.add(hemi, "intensity", 0, 2, 0.01).name("Hemi Intensity");
      ambFolder.add(hemi.position, "y", 0, 200, 1).name("Hemi Height");
      ambFolder
        .addColor({ sky: "#ffffff" }, "sky")
        .name("Hemi Sky Color")
        .onChange((v) => hemi.color.set(v));
      ambFolder
        .addColor({ ground: "#404040" }, "ground")
        .name("Hemi Ground Color")
        .onChange((v) => hemi.groundColor.set(v));
      ambFolder.open();

      // Directional
      const lightFolder = gui.addFolder("Directional Light");
      lightFolder.add(dirLight, "intensity", 0, 2, 0.01).name("Intensity");
      lightFolder
        .add(dirLight.position, "x", -100, 100, 0.1)
        .name("Pos X")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(dirLight.position, "y", 0, 100, 0.1)
        .name("Pos Y")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(dirLight.position, "z", -100, 100, 0.1)
        .name("Pos Z")
        .onChange(() => dirHelper.update());
      lightFolder
        .add(lightTarget.position, "x", -50, 50, 0.1)
        .name("Target X")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .add(lightTarget.position, "y", -50, 50, 0.1)
        .name("Target Y")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .add(lightTarget.position, "z", -50, 50, 0.1)
        .name("Target Z")
        .onChange(() => {
          dirLight.target.updateMatrixWorld();
          dirHelper.update();
        });
      lightFolder
        .addColor({ color: "#ffffff" }, "color")
        .name("Color")
        .onChange((v) => {
          dirLight.color.set(v);
          dirHelper.update();
        });
      lightFolder.add(dirHelper, "visible").name("Show Dir Helper");
      lightFolder.add(camHelper, "visible").name("Show Shadow Cam");

      // Shadows tuning
      const shadowFolder = lightFolder.addFolder("Shadow");
      shadowFolder
        .add(dirLight.shadow, "bias", -0.01, 0.01, 0.0001)
        .name("Bias");
      shadowFolder
        .add(dirLight.shadow, "normalBias", 0, 2, 0.01)
        .name("Normal Bias");
      shadowFolder
        .add(dirLight.shadow.camera, "near", 0.1, 50, 0.1)
        .name("Cam Near")
        .onChange(() => {
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      shadowFolder
        .add(dirLight.shadow.camera, "far", 10, 500, 1)
        .name("Cam Far")
        .onChange(() => {
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      shadowFolder
        .add({ size: SHADOW_SIZE }, "size", 10, 200, 1)
        .name("Frustum Size")
        .onChange((v) => {
          dirLight.shadow.camera.left = -v;
          dirLight.shadow.camera.right = v;
          dirLight.shadow.camera.top = v;
          dirLight.shadow.camera.bottom = -v;
          dirLight.shadow.camera.updateProjectionMatrix();
          camHelper.update();
        });
      lightFolder.open();

      //-------------------Ground-----------------------------

      // Add ground plane with texture
      const groundTexture = new THREE.TextureLoader().load(
        "https://ghost6910.github.io/GhostModel.github.io/Poliigon_GrassPatchyGround_4585_BaseColor.jpg"
      );
      groundTexture.wrapS = THREE.RepeatWrapping;
      groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(8, 8);

      // Create ground plane
      const groundGeo = new THREE.PlaneGeometry(7.5, 13.5);
      const groundMat = new THREE.MeshStandardMaterial({
        map: groundTexture,
        roughness: 0.8,
        metalness: 0.2,
      });

      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      // Set scene background
      scene.background = new THREE.Color(0xbfd1e5);
      const bgTexture = new THREE.TextureLoader().load("");
      scene.background = bgTexture;

      //-------------------Model-----------------------------

      // GLTF/GLB
      const draco = new THREE.DRACOLoader();
      draco.setDecoderPath(
        "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/"
      );

      const loader = new THREE.GLTFLoader();
      loader.setDRACOLoader(draco);

      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/Ramen.glb",
        (gltf) => {
          const shopmodel = gltf.scene;
          shopmodel.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          shopmodel.position.set(1.5, 0.2, 0);
          scene.add(shopmodel);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //CHdeath
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/CHdeath.glb",
        (gltf) => {
          const CHdeath = gltf.scene;
          CHdeath.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          CHdeath.position.set(0, 1, -22.92);
          CHdeath.scale.set(0.004, 0.004, 0.004);
          CHdeath.rotation.y = Math.PI / 2;
          scene.add(CHdeath);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //hddr1
      let hddr1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/hddr1.glb",
        (gltf) => {
          hddr1 = gltf.scene;
         hddr1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          hddr1.position.set(1,1,1);
          hddr1.scale.set(100,100,100);
          scene.add(hddr1);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // Makima
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/makima.glb",
        (gltf) => {
          const makima = gltf.scene;
          makima.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          makima.position.set(0.6, 0.2, -0.05);
          makima.scale.set(1, 1, 1);
          //makima.rotation.y = Math.PI / 2;
          makima.rotation.y = THREE.MathUtils.degToRad(45);
          scene.add(makima);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // G.host
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/G.host.glb",
        (gltf) => {
          const Ghost = gltf.scene;
          Ghost.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          Ghost.position.set(-1.3, 0.8, 5.5);
          Ghost.scale.set(1, 1, 1);
          //makima.rotation.y = Math.PI / 2;
          Ghost.rotation.y = THREE.MathUtils.degToRad(130);
          scene.add(Ghost);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //Pochita
      let pochita;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/pochita.glb",
        (gltf) => {
          pochita = gltf.scene;
          // ปรับวัสดุของ pochita ให้เห็นชัด
          pochita.traverse((o) => {
            if (o.isMesh && o.material) {
              // เพิ่มค่า metalness/roughness ให้เหมาะกับไฟ
              o.material.metalness = 0.5;
              o.material.roughness = 0.3;
              o.material.envMapIntensity = 1.2;
              o.material.needsUpdate = true;
            }
          });

          pochita.position.set(-1.96, 1.4, -4.3);
          pochita.scale.set(0.5, 0.5, 0.5);

          // เพิ่มไฟเฉพาะที่ส่อง pochita
          const ballLight = new THREE.SpotLight(0xffffff, 1.2);
          ballLight.position.set(-2, 2, -3);
          ballLight.angle = Math.PI / 6;
          ballLight.penumbra = 0.3;
          ballLight.castShadow = true;
          ballLight.target = pochita;
          scene.add(ballLight);
          scene.add(ballLight.target);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //vinyl_record
      let vinyl_record;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/vinyl_record.glb",
        (gltf) => {
          vinyl_record = gltf.scene;
          // ปรับวัสดุของ vinyl_record ให้เห็นชัด
          vinyl_record.traverse((o) => {
            if (o.isMesh && o.material) {
              // เพิ่มค่า metalness/roughness ให้เหมาะกับไฟ
              o.material.metalness = 0.2;
              o.material.roughness = 0;
              o.material.envMapIntensity = 1.2;
              o.material.needsUpdate = true;
            }
          });

          vinyl_record.position.set(1.4, 1.6, -25.3);
          vinyl_record.scale.set(4, 4, 4);

          // เพิ่มไฟเฉพาะที่ส่อง vinyl_record
          const ballLight1 = new THREE.SpotLight(0xffffff, 1.2);
          ballLight1.position.set(-2, 2, -3);
          ballLight1.angle = Math.PI / 6;
          ballLight1.penumbra = 0.3;
          ballLight1.castShadow = false;
          ballLight1.target = vinyl_record;
          scene.add(ballLight1);
          scene.add(ballLight1.target);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // clip_b
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/Clip.glb",
        (gltf) => {
          const Clip = gltf.scene;
          Clip.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          Clip.position.set(0.7, 1.5, 0.1);
          Clip.scale.set(0.17, 0.17, 0.17);
          Clip.rotation.y = Math.PI / 2;
          Clip.rotation.z = Math.PI / 2;
          const tabledjLight = new THREE.SpotLight(0xffffff, 1.2);
          tabledjLight.position.set(1.5, 2.5, 1); // ปรับตำแหน่งไฟ
          tabledjLight.angle = Math.PI / 6;
          tabledjLight.penumbra = 0.3;
          tabledjLight.castShadow = true;
          tabledjLight.target = Clip;
          scene.add(tabledjLight);
          scene.add(tabledjLight.target);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //aboutme1
      let aboutme1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/aboutme1.glb",
        (gltf) => {
          aboutme1 = gltf.scene;
          aboutme1.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }

                o.material.color.set(0x969696);
                //0xffffff = ขาว, 0x000000 = ดำ, 0x00ff00 = เขียว

                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          aboutme1.position.set(0.8, 1.4, 0.55);
          aboutme1.scale.set(0.11, 0.11, 0.11);
          aboutme1.rotation.y = Math.PI / 2;
          scene.add(aboutme1);
          backRoots.push(aboutme1);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //Pbrtext
      let Pbrtext;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/Pbrtext.glb",
        (gltf) => {
          Pbrtext = gltf.scene;
          Pbrtext.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                // ถ้ามี texture map ให้ตั้ง encoding
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }

                o.material.color.set(0x969696);
                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          Pbrtext.position.set(0.8, 1.55, 0.61);
          Pbrtext.scale.set(0.09, 0.09, 0.09);
          Pbrtext.rotation.y = Math.PI / 2;
          scene.add(Pbrtext);
          backRoots.push(Pbrtext);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //My name
      let nameGG;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/nameGG.glb",
        (gltf) => {
          nameGG = gltf.scene;
          nameGG.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;

              if (o.material) {
                // ถ้ามี texture map ให้ตั้ง encoding
                if (o.material.map) {
                  o.material.map.encoding = THREE.sRGBEncoding;
                }
                o.material.color.set(0xff6600); 
                o.material.metalness = 0.2; // ทำให้ไม่เงาเกินไป
                o.material.roughness = 0.6; // ปรับผิวให้ดูเป็นด้าน

                o.material.needsUpdate = true;
              }
            }
          });
          nameGG.position.set(-1.9, 1.4, 4.3);
          nameGG.scale.set(0.15, 0.15, 0.15);
          nameGG.rotation.y = Math.PI / 2;
          scene.add(nameGG);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back right
      let backright;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backright.glb",
        (gltf) => {
          backright = gltf.scene;
          backright.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backright.position.set(-1.9, 1.15, 4.65);
          backright.scale.set(0.15, 0.15, 0.15);
          backright.rotation.y = Math.PI / 2;
          scene.add(backright);
          backRoots.push(backright);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back right
      let backright1;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backright.glb",
        (gltf) => {
          backright1 = gltf.scene;
          backright1.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backright1.position.set(-1.4, 1.4, -4.3);
          backright1.scale.set(0.15, 0.15, 0.15);
          //backright1.rotation.y = Math.PI / 2;
          scene.add(backright1);
          backRoots.push(backright1);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      //back left
      let backleft;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/backleft.glb",
        (gltf) => {
          backleft = gltf.scene;
          backleft.traverse((o) => {
            if (o.isMesh) {
              o.material = backMat; // ใช้ material ร่วมกัน
              o.castShadow = false;
              o.receiveShadow = false;
            }
          });
          backleft.position.set(-0.3, 1.15, -18.47);
          backleft.scale.set(0.15, 0.15, 0.15);
          //backleft.rotation.y = Math.PI / 2;
          scene.add(backleft);
          backRoots.push(backleft);
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // musicd
      let musicd;
      loader.load(
        "https://Ghost6910.github.io/PortfolioG.github.io/model/vinyl_single.glb",
        (gltf) => {
          musicd = gltf.scene;
          musicd.traverse((o) => {
            if (o.isMesh) {
              o.castShadow = true;
              o.receiveShadow = true;
              if (o.material && o.material.map) {
                o.material.map.encoding = THREE.sRGBEncoding;
                o.material.needsUpdate = true;
              }
            }
          });
          musicd.position.set(0.75, 1.5, 0.92);
          musicd.scale.set(0.14, 0.14, 0.14);
          musicd.rotateX(-Math.PI / 2);
          musicd.rotation.z = THREE.MathUtils.degToRad(270);
          scene.add(musicd);
          backRoots.push(musicd);
          musicd.userData.clickSound = new Audio(
            "https://Ghost6910.github.io/PortfolioG.github.io/sound/CHAINSAW_MAN_Opening_KICK_BACK.mp3"
          );
          musicd.userData.clickSound.preload = "auto";
          musicd.userData.clickSound.volume = 0.2;
          musicd.traverse((o) => {
            if (o.isMesh && o.material && o.material.color) {
              o.userData.baseColor = o.material.color.clone();
            }
          });
        },
        (xhr) =>
          console.log(
            `Loading: ${(xhr.total
              ? (xhr.loaded / xhr.total) * 100
              : 0
            ).toFixed(1)}%`
          ),
        (err) => console.error(err)
      );

      // Loop
      (function animate() {
        requestAnimationFrame(animate);
        const dt = (
          window.__clock || (window.__clock = new THREE.Clock())
        ).getDelta();

        if (pochita) {
          pochita.rotation.y += 0.01;
        }
        if (vinyl_record) {
          vinyl_record.rotation.z += 0.01;
        }
        if (musicd) {
          musicd.rotation.x += 0.01;
        }

        backMat.uniforms.uTime.value = performance.now() * 0.001;
        // เวลาให้ shader ทั้งคู่
        const t = performance.now() * 0.001;
        backMat.uniforms.uTime.value = t;
        backMatHover.uniforms.uTime.value = t;

        // ตรวจจับชี้และสลับสีเขียวให้เฉพาะตัวที่ถูกชี้
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(backRoots, true);
        let hoveredRoot = null;
        if (hits.length) {
          const hit = hits[0].object;
          hoveredRoot = backRoots.find(
            (root) =>
              hit === root || root.children.includes(hit) || root === hit.parent
          );
        }
        for (const root of backRoots) {
          if (root === musicd) {
            root.traverse((o) => {
              if (o.isMesh && o.material && o.material.color) {
                if (hoveredRoot === musicd) {
                  o.material.color.set(0x00ff00);
                } else if (o.userData.baseColor) {
                  o.material.color.copy(o.userData.baseColor);
                }
              }
            });
          } else {
            root.traverse((o) => {
              if (o.isMesh) {
                o.material = root === hoveredRoot ? backMatHover : backMat;
              }
            });
          }
        }

        // ==== Lerp กล้องเมื่อมีคำสั่งย้ายมุม ====
        if (camLerping) {
          camera.position.lerp(camTargetPos, 0.08);
          controls.target.lerp(camTargetLook, 0.08);
          controls.update();

          // หยุดเมื่อใกล้พอ
          if (
            camera.position.distanceTo(camTargetPos) < 0.02 &&
            controls.target.distanceTo(camTargetLook) < 0.02
          ) {
            camera.position.copy(camTargetPos);
            controls.target.copy(camTargetLook);
            camLerping = false;
          }
        }

        renderer.render(scene, camera);
      })();

      // Resize
      window.addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
